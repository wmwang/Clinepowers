# ClinePower 使用手冊

> 適用平台：Claude Code、Cursor、Cline、Codex、OpenCode

---

## 什麼是 ClinePower？

ClinePower 是一套可組合的「技能（Skill）」框架，讓 AI Coding Agent 在協助你開發時，能自動遵循一套嚴謹、可重現的軟體開發流程。

**核心概念：** AI 不會直接跳進去寫程式，而是先問清楚你要做什麼、設計好方案、然後按計畫有序執行。

### 你會感受到的差異

| 沒有 ClinePower | 有 ClinePower |
|---|---|
| AI 直接開始寫程式 | 先確認需求、提問、設計 |
| 容易做出你沒要求的功能 | 嚴守 YAGNI，不多做 |
| 測試事後補 | 強制 TDD，測試先寫 |
| 難以追蹤進度 | 每個 Task 有明確的驗收標準 |
| 一次修改一堆東西 | 逐 Task 執行，可隨時介入 |

---

## 安裝

### Claude Code

```bash
/plugin marketplace add obra/clinepower-marketplace
/plugin install clinepower@clinepower-marketplace
```

### Cursor

在 Cursor Agent 聊天框中輸入：

```
/plugin-add clinepower
```

### Cline（VS Code 擴充套件）

告訴 Cline：

```
Fetch and follow instructions from https://raw.githubusercontent.com/obra/clinepower/main/.cline/INSTALL.md
```

或手動安裝：

```bash
git clone https://github.com/obra/clinepower.git ~/.cline/clinepower
mkdir -p ~/.agents/skills
ln -s ~/.cline/clinepower/skills ~/.agents/skills/clinepower
```

### Codex

告訴 Codex：

```
Fetch and follow instructions from https://raw.githubusercontent.com/obra/clinepower/refs/heads/main/.codex/INSTALL.md
```

### OpenCode

告訴 OpenCode：

```
Fetch and follow instructions from https://raw.githubusercontent.com/obra/clinepower/refs/heads/main/.opencode/INSTALL.md
```

### 驗證安裝

開新對話，輸入：「幫我規劃這個功能」或「我遇到一個 bug 需要除錯」。Agent 應該會自動載入對應的技能。

---

## 完整開發工作流程

以下是 ClinePower 設計的標準開發流程，技能會在正確的時機自動觸發。

### 第一階段：需求釐清（brainstorming）

當你說「我想做 X 功能」時觸發。

**Agent 會做什麼：**
1. 先了解專案目前的狀態（檔案、文件、最近的 commit）
2. 每次問一個問題，逐步釐清你的想法
3. 提出 2-3 個不同的設計方案，說明各自的取捨
4. 分段呈現設計，每段確認你是否同意
5. 把確認好的設計存到 `docs/plans/YYYY-MM-DD-<主題>-design.md`

**你需要做什麼：** 回答問題、選擇方案、確認設計。

> **注意：** 在你確認設計之前，Agent 不會寫任何程式碼。

---

### 第二階段：建立隔離工作區（using-git-worktrees）

設計確認後自動觸發。

**Agent 會做什麼：**
1. 找到或建立 worktree 目錄（`.worktrees/` 或 `worktrees/`）
2. 確認該目錄在 `.gitignore` 中（避免誤 commit）
3. 建立新的 git worktree 與分支
4. 安裝相依套件（自動偵測 npm/cargo/pip 等）
5. 執行測試確認基線通過

**好處：** 你的 main 分支完全不受影響，隨時可以回到原本的工作。

---

### 第三階段：撰寫實作計畫（writing-plans）

設計確認後觸發。

**Agent 會做什麼：** 把設計拆解成每個 2-5 分鐘的小 Task，每個 Task 包含：
- 要修改的確切檔案路徑
- 完整的程式碼（不是「新增驗證邏輯」，而是完整的程式）
- 確切的測試指令與預期輸出
- Commit 指令

計畫存到 `docs/plans/YYYY-MM-DD-<功能名>.md`。

---

### 第四階段：執行計畫

有兩種執行模式，計畫完成後 Agent 會問你選哪種：

#### 模式 A：子任務驅動開發（subagent-driven-development）

在同一個對話中執行，每個 Task 派一個新的子 Agent：

- 子 Agent 實作 → 自我審查 → 回報
- 規格審查員確認是否符合計畫（規格審查）
- 程式碼品質審查員確認程式品質（品質審查）
- 通過後才繼續下一個 Task

**適合：** 想快速迭代、不想切換視窗。

#### 模式 B：批次執行（executing-plans）

在新的對話（session）中執行，每次執行 3 個 Task 後停下來等你確認：

- 執行 → 回報 → 等你回饋 → 繼續

**適合：** 需要更細緻的人工監控，或在另一個背景執行。

---

### 第五階段：TDD 執行（test-driven-development）

每個 Task 實作時自動觸發。

**鐵律：** 沒有失敗的測試，不能寫任何正式程式碼。

流程：
1. **RED**：寫一個最小的失敗測試
2. **確認 RED**：執行測試，確認它確實失敗（且失敗原因正確）
3. **GREEN**：寫最少量的程式碼讓測試通過
4. **確認 GREEN**：執行測試，確認通過
5. **REFACTOR**：在測試繼續通過的前提下整理程式碼

> 如果在測試之前寫了程式碼，必須刪掉重來。

---

### 第六階段：程式碼審查（requesting-code-review）

每個 Task 完成後觸發。

Agent 會派一個審查員子任務，回報：
- **Critical**：阻塞問題，必須立即修復
- **Important**：重要問題，繼續前應修復
- **Minor**：小問題，記錄留待後續

---

### 第七階段：完成分支（finishing-a-development-branch）

所有 Task 完成後觸發。

Agent 會：
1. 執行完整測試，確認全部通過
2. 提供四個選項：
   - 合併回主分支（本機）
   - Push 並建立 Pull Request
   - 保留分支（稍後處理）
   - 捨棄此次工作

---

## 其他實用技能

### systematic-debugging（系統性除錯）

遇到 bug 時觸發。強制你在提出修復方案之前，先完成：

1. **根因調查**：讀錯誤訊息、重現問題、查最近的變更
2. **模式分析**：找到可正常運作的相似程式碼，比較差異
3. **假設與測試**：一次只改一件事，驗證假設
4. **實作**：找到根因後才動手修

> 如果嘗試 3 次修復都失敗，停下來，討論是否是架構問題。

### verification-before-completion（完成前驗證）

宣稱工作完成之前觸發。

**鐵律：** 沒有執行驗證指令，不能說「完成了」、「測試通過」。

### dispatching-parallel-agents（平行分派子任務）

有多個獨立問題需要同時處理時觸發（例如：3 個不同測試檔案各自有不同的失敗）。每個問題派一個子 Agent 平行處理。

### receiving-code-review（接收審查意見）

收到程式碼審查回饋時觸發。

重點：
- 先理解、驗證，再實作——不盲目執行建議
- 不確定的項目先問清楚再動手
- 如果建議有誤，提出技術性理由反駁

---

## 全部技能一覽

| 技能名稱 | 觸發時機 | 類型 |
|---|---|---|
| `using-clinepower` | 每次對話開始 | Bootstrap |
| `brainstorming` | 要建立新功能前 | 流程 |
| `using-git-worktrees` | 設計確認後 | 流程 |
| `writing-plans` | 有設計文件後 | 流程 |
| `subagent-driven-development` | 要執行計畫（同一對話） | 執行 |
| `executing-plans` | 要執行計畫（新對話） | 執行 |
| `test-driven-development` | 實作任何功能或修 bug | 紀律 |
| `requesting-code-review` | Task 完成後 | 品質 |
| `receiving-code-review` | 收到審查意見後 | 品質 |
| `finishing-a-development-branch` | 所有 Task 完成後 | 流程 |
| `systematic-debugging` | 遇到 bug / 非預期行為 | 紀律 |
| `verification-before-completion` | 宣稱完成前 | 紀律 |
| `dispatching-parallel-agents` | 多個獨立問題並行 | 效率 |
| `writing-skills` | 要建立新技能時 | 元技能 |

---

## 常見問題

**Q：技能自動觸發嗎？我需要手動呼叫嗎？**

A：技能由 `using-clinepower` 這個 bootstrap 技能管理。只要 ClinePower 安裝好，Agent 在每次回應前都會判斷是否有適用的技能，並自動載入。你不需要手動呼叫。

**Q：如果我只想做一個小改動，也要走完整個流程嗎？**

A：brainstorming 技能的說明指出：「設計文件可以很短（幾句話），但必須呈現並確認」。小改動也要過，但過程可以非常快速。

**Q：技能和 `.clinerules` / `CLAUDE.md` 的關係是什麼？**

A：`.clinerules` 和 `CLAUDE.md` 是描述「你的專案偏好」（例如：使用哪個框架、命名規則）。ClinePower 技能是描述「AI 應該如何工作」（流程、紀律）。兩者互補，不衝突。

**Q：可以建立自己的技能嗎？**

A：可以。技能是 Markdown 檔案，放在正確的目錄就會被自動發現。詳見開發手冊。

**Q：如何更新 ClinePower？**

A：
- Claude Code：`/plugin update clinepower`
- Cline / Codex：`cd ~/.cline/clinepower && git pull`（或對應的安裝目錄）

---

## 聯絡與支援

- **問題回報**：https://github.com/obra/clinepower/issues
- **Marketplace**：https://github.com/obra/clinepower-marketplace
- **作者部落格**：https://blog.fsck.com/2025/10/09/clinepower/
