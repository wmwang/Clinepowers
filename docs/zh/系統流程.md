# ClinePower 系統流程

本文件以流程圖與說明描述 ClinePower 的運作機制。

---

## 一、整體工作流程

```
使用者發出請求
      │
      ▼
┌─────────────────────────────────────┐
│         using-clinepower           │
│   （Bootstrap，每次對話都會載入）      │
│                                     │
│  檢查：是否有任何技能可能適用？        │
│  若有（哪怕只有 1% 機率）→ 載入技能    │
└─────────────────────────────────────┘
      │
      ├──── 要建立新功能？
      │         └──→ [brainstorming]
      │                  └──→ [using-git-worktrees]
      │                           └──→ [writing-plans]
      │                                    └──→ 選擇執行模式
      │                                         ├──→ [subagent-driven-development]
      │                                         └──→ [executing-plans]
      │
      ├──── 遇到 Bug？
      │         └──→ [systematic-debugging]
      │                  └──→ [test-driven-development]（Phase 4）
      │                           └──→ [verification-before-completion]
      │
      ├──── 要完成分支？
      │         └──→ [finishing-a-development-branch]
      │
      └──── 要審查程式碼？
                └──→ [requesting-code-review] / [receiving-code-review]
```

---

## 二、功能開發主流程

### 2.1 從需求到上線的完整流程

```
使用者：「我想做 X 功能」
      │
      ▼
╔════════════════════════╗
║     brainstorming      ║  目標：把模糊想法變成具體設計
╠════════════════════════╣
║ 1. 了解專案現況         ║
║ 2. 逐一提問（每次一個） ║
║ 3. 提出 2-3 種方案      ║
║ 4. 分段呈現設計         ║  ◄── 每段都要使用者確認
║ 5. 儲存設計文件         ║
╚════════════════════════╝
      │ 使用者：「確認設計」
      ▼
╔════════════════════════╗
║  using-git-worktrees   ║  目標：建立安全的隔離工作區
╠════════════════════════╣
║ 1. 尋找 worktree 目錄  ║
║ 2. 確認已在 .gitignore ║
║ 3. 建立新分支          ║
║ 4. 安裝相依套件        ║
║ 5. 確認基線測試通過    ║
╚════════════════════════╝
      │
      ▼
╔════════════════════════╗
║     writing-plans      ║  目標：產生詳細實作計畫
╠════════════════════════╣
║ 每個 Task 包含：        ║
║  - 確切檔案路徑         ║
║  - 完整程式碼片段       ║
║  - 測試指令與預期輸出   ║
║  - Commit 指令         ║
╚════════════════════════╝
      │
      ├─── 選模式 A ──→ [subagent-driven-development]
      │
      └─── 選模式 B ──→ [executing-plans]
```

### 2.2 子任務驅動開發（模式 A）

```
讀取計畫，建立所有 Task 的待辦清單
      │
      ▼
┌─────────────── 每個 Task ───────────────┐
│                                          │
│  派出【實作子 Agent】                    │
│      │                                   │
│      ├── 子 Agent 有問題？               │
│      │       └──→ 主 Agent 回答 → 重派   │
│      │                                   │
│      └── 子 Agent 實作完成              │
│              │                           │
│              ▼                           │
│  派出【規格審查員】                      │
│      │                                   │
│      ├── 不符合規格？                    │
│      │       └──→ 實作子 Agent 修正     │
│      │               └──→ 重新規格審查  │
│      │                                   │
│      └── 規格通過 ✅                    │
│              │                           │
│              ▼                           │
│  派出【品質審查員】                      │
│      │                                   │
│      ├── 品質有問題？                    │
│      │       └──→ 實作子 Agent 修正     │
│      │               └──→ 重新品質審查  │
│      │                                   │
│      └── 品質通過 ✅                    │
│              │                           │
│              ▼                           │
│      標記 Task 完成                      │
└─────────────────────────────────────────┘
      │ 所有 Task 完成
      ▼
  派出【最終程式碼審查員】
      │
      ▼
  [finishing-a-development-branch]
```

### 2.3 批次執行（模式 B）

```
讀取計畫，建立待辦清單
      │
      ▼
┌──────────────────────────────┐
│   執行一批（預設 3 個 Task） │
│   每個 Task：                 │
│     標記進行中                │
│     → 執行步驟               │
│     → 執行驗證               │
│     → 標記完成               │
└──────────────────────────────┘
      │
      ▼
  回報此批成果，等待回饋
      │
      ├── 有修改？ → 套用 → 繼續下一批
      │
      └── 沒問題 → 繼續下一批

      │ 所有批次完成
      ▼
  [finishing-a-development-branch]
```

---

## 三、TDD 執行流程

```
需要實作功能或修 Bug
      │
      ▼
╔═══════════════════════════════════╗
║      test-driven-development      ║
╚═══════════════════════════════════╝
      │
      ▼
  ┌─── RED 階段 ────────────────────┐
  │  寫一個最小的失敗測試            │
  │        │                        │
  │        ▼                        │
  │  執行測試                       │
  │        │                        │
  │        ├── 通過了？→ 測試有誤   │
  │        │       └──→ 重寫測試    │
  │        │                        │
  │        ├── 錯誤原因不對？        │
  │        │       └──→ 修正測試    │
  │        │                        │
  │        └── 正確失敗 ✅          │
  └──────────────────────────────────┘
      │
      ▼
  ┌─── GREEN 階段 ───────────────────┐
  │  寫最少量的程式碼讓測試通過       │
  │        │                         │
  │        ▼                         │
  │  執行所有測試                    │
  │        │                         │
  │        ├── 有測試失敗？ → 修正   │
  │        └── 全部通過 ✅           │
  └───────────────────────────────────┘
      │
      ▼
  ┌─── REFACTOR 階段 ────────────────┐
  │  整理程式碼（不改行為）           │
  │  消除重複、改善命名               │
  │  持續確認測試繼續通過             │
  └───────────────────────────────────┘
      │
      ▼
  Commit → 下一個功能
```

---

## 四、除錯流程

```
遇到 Bug / 測試失敗 / 非預期行為
      │
      ▼
╔═══════════════════════════════════╗
║       systematic-debugging        ║
╚═══════════════════════════════════╝

Phase 1：根因調查（必須完成才能提出修復方案）
  ├── 仔細讀錯誤訊息
  ├── 確認能穩定重現
  ├── 檢查最近的變更（git diff）
  ├── 多元件系統：加入診斷日誌，找出哪層出問題
  └── 追蹤資料流（從錯誤往上追到根源）

      │
      ▼

Phase 2：模式分析
  ├── 找到可正常運作的相似程式碼
  ├── 完整讀完參考實作
  └── 列出所有差異

      │
      ▼

Phase 3：假設與測試
  ├── 提出單一假設：「我認為 X 是根因，因為 Y」
  ├── 做最小的改動來驗證
  ├── 通過 → Phase 4
  └── 失敗 → 回到 Phase 1，帶著新資訊重新分析

      │
      ▼

Phase 4：實作修復
  ├── 先寫失敗測試（重現 bug）
  ├── 實作修復
  └── 確認測試通過，其他測試未受影響

      │
      ▼

【特殊情況】嘗試 3 次以上都失敗？
  └──→ 停下來，討論是否是架構問題
        不要嘗試第 4 次修復
```

---

## 五、技能觸發機制

### 技能如何被發現

```
對話開始
    │
    ▼
平台載入 using-clinepower（bootstrap）
    │
    ▼
使用者發出訊息
    │
    ▼
Agent 掃描所有技能的 description 欄位（只讀 frontmatter，約 100 tokens/技能）
    │
    ▼
    ├── 有匹配的技能？ → 呼叫 use_skill / Skill 工具載入完整內容
    │                           │
    │                           ▼
    │                   讀取 SKILL.md 正文（按需載入）
    │                           │
    │                           ▼
    │                   遵照技能說明執行
    │
    └── 沒有匹配 → 直接回應
```

### 技能優先順序

```
收到訊息後，若多個技能都適用：

1. 流程技能優先（brainstorming、systematic-debugging）
   └── 這些決定「如何處理這個問題」

2. 實作技能其次（test-driven-development、verification-before-completion）
   └── 這些決定「如何執行這個動作」

例如：「幫我建立一個 API」
  → brainstorming（確認設計）先執行
  → 設計確認後，writing-plans（寫計畫）
  → 執行時，test-driven-development（TDD）
```

---

## 六、技能之間的相依關係

```
brainstorming
    └──→ using-git-worktrees（必要，建立隔離環境）
    └──→ writing-plans（必要，產生實作計畫）
              └──→ subagent-driven-development（模式 A）
              │         └──→ requesting-code-review（每個 Task 後）
              │         └──→ finishing-a-development-branch（全部完成後）
              │
              └──→ executing-plans（模式 B）
                        └──→ finishing-a-development-branch（全部完成後）

test-driven-development
    ← 被 subagent-driven-development 的子 Agent 使用
    ← 被 systematic-debugging 的 Phase 4 使用

systematic-debugging
    └──→ test-driven-development（Phase 4：建立失敗測試）
    └──→ verification-before-completion（確認修復有效）

finishing-a-development-branch
    ← 被 subagent-driven-development 呼叫
    ← 被 executing-plans 呼叫
    └──→ using-git-worktrees（清理 worktree）

dispatching-parallel-agents
    ← 當有多個獨立問題需要同時處理時使用
    └── 每個子 Agent 可能使用 systematic-debugging 或 test-driven-development

receiving-code-review
    ← 收到外部審查意見時使用
    └──→ verification-before-completion（確認修改有效）
```

---

## 七、各平台技能載入比較

```
Claude Code:
  Plugin Marketplace 安裝
        │
        ▼
  對話開始 → using-clinepower 注入 system prompt
        │
        ▼
  使用者請求 → Agent 呼叫 Skill tool → 載入對應 SKILL.md

─────────────────────────────────────────────────────

Cline / Codex:
  symlink skills/ → ~/.agents/skills/clinepower/
        │
        ▼
  對話開始 → 掃描 ~/.agents/skills/，讀取所有 frontmatter
        │
        ▼
  使用者請求 → Agent 呼叫 use_skill tool → 載入對應 SKILL.md

─────────────────────────────────────────────────────

OpenCode:
  JS Plugin (clinepower.js) 安裝
        │
        ▼
  對話開始 → experimental.chat.system.transform hook
           → 自動注入 using-clinepower 到 system prompt
        │
        ▼
  使用者請求 → Agent 使用 OpenCode 原生 skill tool
```

---

## 八、Token 使用模式

ClinePower 的設計最大化使用 prompt caching：

```
主協調 Agent（Coordinator）
├── 讀取計畫一次，擷取所有 Task 全文
├── 每個子 Agent 收到「完整任務說明 + 必要上下文」
│   └── 子 Agent 不需要自己讀計畫文件（省 I/O）
└── Cache 大量重複的 system prompt 內容

典型費用分布（以 subagent-driven-development 為例）：
  主 Agent：$4.09（含大量 cache read）
  每個子 Agent：$0.07-$0.09
  整體：$4.67（7 個子 Agent）
```

Cache read token 遠多於 cache creation token，代表快取運作良好。
